// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
    TypedMap,
    Entity,
    Value,
    ValueKind,
    store,
    Bytes,
    BigInt,
    BigDecimal,
} from "@graphprotocol/graph-ts"

export class NftCatAttributesCreated extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save NftCatAttributesCreated entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.BYTES,
                `Entities of type NftCatAttributesCreated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("NftCatAttributesCreated", id.toBytes().toHexString(), this)
        }
    }

    static load(id: string): NftCatAttributesCreated | null {
        return changetype<NftCatAttributesCreated | null>(store.get("NftCatAttributesCreated", id))
    }

    get id(): Bytes {
        let value = this.get("id")
        return value!.toBytes()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get requestId(): BigInt {
        let value = this.get("requestId")
        return value!.toBigInt()
    }

    set requestId(value: BigInt) {
        this.set("requestId", Value.fromBigInt(value))
    }

    get requester(): Bytes {
        let value = this.get("requester")
        return value!.toBytes()
    }

    set requester(value: string) {
        this.set("requester", Value.fromString(value))
    }

    get breed(): i32 {
        let value = this.get("breed")
        return value!.toI32()
    }

    set breed(value: i32) {
        this.set("breed", Value.fromI32(value))
    }

    get eyecolor(): i32 {
        let value = this.get("eyecolor")
        return value!.toI32()
    }

    set eyecolor(value: i32) {
        this.set("eyecolor", Value.fromI32(value))
    }

    get playfulness(): BigInt {
        let value = this.get("playfulness")
        return value!.toBigInt()
    }

    set playfulness(value: BigInt) {
        this.set("playfulness", Value.fromBigInt(value))
    }

    get cuteness(): BigInt {
        let value = this.get("cuteness")
        return value!.toBigInt()
    }

    set cuteness(value: BigInt) {
        this.set("cuteness", Value.fromBigInt(value))
    }

    get blockNumber(): BigInt {
        let value = this.get("blockNumber")
        return value!.toBigInt()
    }

    set blockNumber(value: BigInt) {
        this.set("blockNumber", Value.fromBigInt(value))
    }

    get blockTimestamp(): BigInt {
        let value = this.get("blockTimestamp")
        return value!.toBigInt()
    }

    set blockTimestamp(value: BigInt) {
        this.set("blockTimestamp", Value.fromBigInt(value))
    }

    get transactionHash(): Bytes {
        let value = this.get("transactionHash")
        return value!.toBytes()
    }

    set transactionHash(value: string) {
        this.set("transactionHash", Value.fromString(value))
    }
}

export class NftCatAttributesRequested extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save NftCatAttributesRequested entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.BYTES,
                `Entities of type NftCatAttributesRequested must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("NftCatAttributesRequested", id.toBytes().toHexString(), this)
        }
    }

    static load(id: string): NftCatAttributesRequested | null {
        return changetype<NftCatAttributesRequested | null>(
            store.get("NftCatAttributesRequested", id)
        )
    }

    get id(): Bytes {
        let value = this.get("id")
        return value!.toBytes()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get requestId(): BigInt {
        let value = this.get("requestId")
        return value!.toBigInt()
    }

    set requestId(value: BigInt) {
        this.set("requestId", Value.fromBigInt(value))
    }

    get requester(): Bytes {
        let value = this.get("requester")
        return value!.toBytes()
    }

    set requester(value: string) {
        this.set("requester", Value.fromString(value))
    }

    get blockNumber(): BigInt {
        let value = this.get("blockNumber")
        return value!.toBigInt()
    }

    set blockNumber(value: BigInt) {
        this.set("blockNumber", Value.fromBigInt(value))
    }

    get blockTimestamp(): BigInt {
        let value = this.get("blockTimestamp")
        return value!.toBigInt()
    }

    set blockTimestamp(value: BigInt) {
        this.set("blockTimestamp", Value.fromBigInt(value))
    }

    get transactionHash(): Bytes {
        let value = this.get("transactionHash")
        return value!.toBytes()
    }

    set transactionHash(value: string) {
        this.set("transactionHash", Value.fromString(value))
    }
}

export class OwnershipTransferred extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save OwnershipTransferred entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.BYTES,
                `Entities of type OwnershipTransferred must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("OwnershipTransferred", id.toBytes().toHexString(), this)
        }
    }

    static load(id: string): OwnershipTransferred | null {
        return changetype<OwnershipTransferred | null>(store.get("OwnershipTransferred", id))
    }

    get id(): Bytes {
        let value = this.get("id")
        return value!.toBytes()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get previousOwner(): Bytes {
        let value = this.get("previousOwner")
        return value!.toBytes()
    }

    set previousOwner(value: string) {
        this.set("previousOwner", Value.fromString(value))
    }

    get newOwner(): Bytes {
        let value = this.get("newOwner")
        return value!.toBytes()
    }

    set newOwner(value: string) {
        this.set("newOwner", Value.fromString(value))
    }

    get blockNumber(): BigInt {
        let value = this.get("blockNumber")
        return value!.toBigInt()
    }

    set blockNumber(value: BigInt) {
        this.set("blockNumber", Value.fromBigInt(value))
    }

    get blockTimestamp(): BigInt {
        let value = this.get("blockTimestamp")
        return value!.toBigInt()
    }

    set blockTimestamp(value: BigInt) {
        this.set("blockTimestamp", Value.fromBigInt(value))
    }

    get transactionHash(): Bytes {
        let value = this.get("transactionHash")
        return value!.toBytes()
    }

    set transactionHash(value: string) {
        this.set("transactionHash", Value.fromString(value))
    }
}

export class NftListed extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save NftListed entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.BYTES,
                `Entities of type NftListed must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("NftListed", id.toBytes().toHexString(), this)
        }
    }

    static load(id: string): NftListed | null {
        return changetype<NftListed | null>(store.get("NftListed", id))
    }

    get id(): Bytes {
        let value = this.get("id")
        return value!.toBytes()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get nftId(): BigInt {
        let value = this.get("nftId")
        return value!.toBigInt()
    }

    set nftId(value: BigInt) {
        this.set("nftId", Value.fromBigInt(value))
    }

    get owner(): Bytes {
        let value = this.get("owner")
        return value!.toBytes()
    }

    set owner(value: string) {
        this.set("owner", Value.fromString(value))
    }

    get price(): BigInt {
        let value = this.get("price")
        return value!.toBigInt()
    }

    set price(value: BigInt) {
        this.set("price", Value.fromBigInt(value))
    }

    get ierc721TokenAddress(): Bytes {
        let value = this.get("ierc721TokenAddress")
        return value!.toBytes()
    }

    set ierc721TokenAddress(value: string) {
        this.set("ierc721TokenAddress", Value.fromString(value))
    }

    get blockNumber(): BigInt {
        let value = this.get("blockNumber")
        return value!.toBigInt()
    }

    set blockNumber(value: BigInt) {
        this.set("blockNumber", Value.fromBigInt(value))
    }

    get blockTimestamp(): BigInt {
        let value = this.get("blockTimestamp")
        return value!.toBigInt()
    }

    set blockTimestamp(value: BigInt) {
        this.set("blockTimestamp", Value.fromBigInt(value))
    }

    get transactionHash(): Bytes {
        let value = this.get("transactionHash")
        return value!.toBytes()
    }

    set transactionHash(value: string) {
        this.set("transactionHash", Value.fromString(value))
    }
}

export class NftListingCancelled extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save NftListingCancelled entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.BYTES,
                `Entities of type NftListingCancelled must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("NftListingCancelled", id.toBytes().toHexString(), this)
        }
    }

    static load(id: string): NftListingCancelled | null {
        return changetype<NftListingCancelled | null>(store.get("NftListingCancelled", id))
    }

    get id(): Bytes {
        let value = this.get("id")
        return value!.toBytes()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get nftId(): BigInt {
        let value = this.get("nftId")
        return value!.toBigInt()
    }

    set nftId(value: BigInt) {
        this.set("nftId", Value.fromBigInt(value))
    }

    get owner(): Bytes {
        let value = this.get("owner")
        return value!.toBytes()
    }

    set owner(value: string) {
        this.set("owner", Value.fromString(value))
    }

    get ierc721TokenAddress(): Bytes {
        let value = this.get("ierc721TokenAddress")
        return value!.toBytes()
    }

    set ierc721TokenAddress(value: string) {
        this.set("ierc721TokenAddress", Value.fromString(value))
    }

    get blockNumber(): BigInt {
        let value = this.get("blockNumber")
        return value!.toBigInt()
    }

    set blockNumber(value: BigInt) {
        this.set("blockNumber", Value.fromBigInt(value))
    }

    get blockTimestamp(): BigInt {
        let value = this.get("blockTimestamp")
        return value!.toBigInt()
    }

    set blockTimestamp(value: BigInt) {
        this.set("blockTimestamp", Value.fromBigInt(value))
    }

    get transactionHash(): Bytes {
        let value = this.get("transactionHash")
        return value!.toBytes()
    }

    set transactionHash(value: string) {
        this.set("transactionHash", Value.fromString(value))
    }
}

export class NftListingUpdated extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save NftListingUpdated entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.BYTES,
                `Entities of type NftListingUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("NftListingUpdated", id.toBytes().toHexString(), this)
        }
    }

    static load(id: string): NftListingUpdated | null {
        return changetype<NftListingUpdated | null>(store.get("NftListingUpdated", id))
    }

    get id(): Bytes {
        let value = this.get("id")
        return value!.toBytes()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get nftId(): BigInt {
        let value = this.get("nftId")
        return value!.toBigInt()
    }

    set nftId(value: BigInt) {
        this.set("nftId", Value.fromBigInt(value))
    }

    get owner(): Bytes {
        let value = this.get("owner")
        return value!.toBytes()
    }

    set owner(value: string) {
        this.set("owner", Value.fromString(value))
    }

    get price(): BigInt {
        let value = this.get("price")
        return value!.toBigInt()
    }

    set price(value: BigInt) {
        this.set("price", Value.fromBigInt(value))
    }

    get ierc721TokenAddress(): Bytes {
        let value = this.get("ierc721TokenAddress")
        return value!.toBytes()
    }

    set ierc721TokenAddress(value: string) {
        this.set("ierc721TokenAddress", Value.fromString(value))
    }

    get blockNumber(): BigInt {
        let value = this.get("blockNumber")
        return value!.toBigInt()
    }

    set blockNumber(value: BigInt) {
        this.set("blockNumber", Value.fromBigInt(value))
    }

    get blockTimestamp(): BigInt {
        let value = this.get("blockTimestamp")
        return value!.toBigInt()
    }

    set blockTimestamp(value: BigInt) {
        this.set("blockTimestamp", Value.fromBigInt(value))
    }

    get transactionHash(): Bytes {
        let value = this.get("transactionHash")
        return value!.toBytes()
    }

    set transactionHash(value: string) {
        this.set("transactionHash", Value.fromString(value))
    }
}

export class NftMinted extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save NftMinted entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.BYTES,
                `Entities of type NftMinted must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("NftMinted", id.toBytes().toHexString(), this)
        }
    }

    static load(id: string): NftMinted | null {
        return changetype<NftMinted | null>(store.get("NftMinted", id))
    }

    get id(): Bytes {
        let value = this.get("id")
        return value!.toBytes()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get owner(): Bytes {
        let value = this.get("owner")
        return value!.toBytes()
    }

    set owner(value: string) {
        this.set("owner", Value.fromString(value))
    }

    get tokenId(): BigInt {
        let value = this.get("tokenId")
        return value!.toBigInt()
    }

    set tokenId(value: BigInt) {
        this.set("tokenId", Value.fromBigInt(value))
    }

    get blockNumber(): BigInt {
        let value = this.get("blockNumber")
        return value!.toBigInt()
    }

    set blockNumber(value: BigInt) {
        this.set("blockNumber", Value.fromBigInt(value))
    }

    get blockTimestamp(): BigInt {
        let value = this.get("blockTimestamp")
        return value!.toBigInt()
    }

    set blockTimestamp(value: BigInt) {
        this.set("blockTimestamp", Value.fromBigInt(value))
    }

    get transactionHash(): Bytes {
        let value = this.get("transactionHash")
        return value!.toBytes()
    }

    set transactionHash(value: string) {
        this.set("transactionHash", Value.fromString(value))
    }
}

export class NftRequested extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save NftRequested entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.BYTES,
                `Entities of type NftRequested must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("NftRequested", id.toBytes().toHexString(), this)
        }
    }

    static load(id: string): NftRequested | null {
        return changetype<NftRequested | null>(store.get("NftRequested", id))
    }

    get id(): Bytes {
        let value = this.get("id")
        return value!.toBytes()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get requester(): Bytes {
        let value = this.get("requester")
        return value!.toBytes()
    }

    set requester(value: string) {
        this.set("requester", Value.fromString(value))
    }

    get blockNumber(): BigInt {
        let value = this.get("blockNumber")
        return value!.toBigInt()
    }

    set blockNumber(value: BigInt) {
        this.set("blockNumber", Value.fromBigInt(value))
    }

    get blockTimestamp(): BigInt {
        let value = this.get("blockTimestamp")
        return value!.toBigInt()
    }

    set blockTimestamp(value: BigInt) {
        this.set("blockTimestamp", Value.fromBigInt(value))
    }

    get transactionHash(): Bytes {
        let value = this.get("transactionHash")
        return value!.toBytes()
    }

    set transactionHash(value: string) {
        this.set("transactionHash", Value.fromString(value))
    }
}

export class NftSold extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save NftSold entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.BYTES,
                `Entities of type NftSold must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("NftSold", id.toBytes().toHexString(), this)
        }
    }

    static load(id: string): NftSold | null {
        return changetype<NftSold | null>(store.get("NftSold", id))
    }

    get id(): Bytes {
        let value = this.get("id")
        return value!.toBytes()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get owner(): Bytes {
        let value = this.get("owner")
        return value!.toBytes()
    }

    set owner(value: string) {
        this.set("owner", Value.fromString(value))
    }

    get nftId(): BigInt {
        let value = this.get("nftId")
        return value!.toBigInt()
    }

    set nftId(value: BigInt) {
        this.set("nftId", Value.fromBigInt(value))
    }

    get ierc721TokenAddress(): Bytes {
        let value = this.get("ierc721TokenAddress")
        return value!.toBytes()
    }

    set ierc721TokenAddress(value: string) {
        this.set("ierc721TokenAddress", Value.fromString(value))
    }

    get price(): BigInt {
        let value = this.get("price")
        return value!.toBigInt()
    }

    set price(value: BigInt) {
        this.set("price", Value.fromBigInt(value))
    }

    get blockNumber(): BigInt {
        let value = this.get("blockNumber")
        return value!.toBigInt()
    }

    set blockNumber(value: BigInt) {
        this.set("blockNumber", Value.fromBigInt(value))
    }

    get blockTimestamp(): BigInt {
        let value = this.get("blockTimestamp")
        return value!.toBigInt()
    }

    set blockTimestamp(value: BigInt) {
        this.set("blockTimestamp", Value.fromBigInt(value))
    }

    get transactionHash(): Bytes {
        let value = this.get("transactionHash")
        return value!.toBytes()
    }

    set transactionHash(value: string) {
        this.set("transactionHash", Value.fromString(value))
    }
}

export class NftMarketplaceOwnershipTransferred extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save NftMarketplaceOwnershipTransferred entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.BYTES,
                `Entities of type NftMarketplaceOwnershipTransferred must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("NftMarketplaceOwnershipTransferred", id.toBytes().toHexString(), this)
        }
    }

    static load(id: string): NftMarketplaceOwnershipTransferred | null {
        return changetype<NftMarketplaceOwnershipTransferred | null>(
            store.get("NftMarketplaceOwnershipTransferred", id)
        )
    }

    get id(): Bytes {
        let value = this.get("id")
        return value!.toBytes()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get previousOwner(): Bytes {
        let value = this.get("previousOwner")
        return value!.toBytes()
    }

    set previousOwner(value: string) {
        this.set("previousOwner", Value.fromString(value))
    }

    get newOwner(): Bytes {
        let value = this.get("newOwner")
        return value!.toBytes()
    }

    set newOwner(value: string) {
        this.set("newOwner", Value.fromString(value))
    }

    get blockNumber(): BigInt {
        let value = this.get("blockNumber")
        return value!.toBigInt()
    }

    set blockNumber(value: BigInt) {
        this.set("blockNumber", Value.fromBigInt(value))
    }

    get blockTimestamp(): BigInt {
        let value = this.get("blockTimestamp")
        return value!.toBigInt()
    }

    set blockTimestamp(value: BigInt) {
        this.set("blockTimestamp", Value.fromBigInt(value))
    }

    get transactionHash(): Bytes {
        let value = this.get("transactionHash")
        return value!.toBytes()
    }

    set transactionHash(value: string) {
        this.set("transactionHash", Value.fromString(value))
    }
}
